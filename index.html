<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gesture Controlled 3D Game</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load Three.js (Core) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Load GLTFLoader -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/GLTFLoader.js"></script>
    <!-- MediaPipe Tasks Vision Library -->
    <script type="module" src="https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.12/vision_bundle.js"></script>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Inter', sans-serif; background-color: #0d0d1a; }
        canvas { display: block; width: 100%; height: 100vh; }
        #three-container canvas { cursor: grab; }
        #hand-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100vh; pointer-events: none; z-index: 50; }
        
        #fab-container { 
            position: fixed; 
            bottom: 2rem;
            right: 2rem;
            z-index: 100; 
        }

        #sub-fab-container {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 99;
            pointer-events: none;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.4s ease, visibility 0.4s ease;
        }
        #sub-fab-container.visible {
            opacity: 1;
            visibility: visible;
            pointer-events: auto;
        }

        .fab-button {
            width: 55px; height: 55px; border-radius: 50%; display: flex; align-items: center; justify-content: center;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.6);
            transition: transform 0.2s ease-in-out, background-color 0.2s, filter 0.2s, box-shadow 0.2s;
            cursor: pointer;
        }
        .fab-button:active { transform: scale(0.95); filter: brightness(85%); }
        #main-fab svg { transition: transform 0.3s ease-in-out; }
        #main-fab { position: relative; z-index: 10; }

        .sub-fab {
            position: absolute;
            top: 50%;
            left: 50%;
            margin-top: -27.5px;
            margin-left: -27.5px;
            opacity: 0;
            visibility: hidden;
            transition: all 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            transform: scale(0.5); 
            z-index: 5;
        }

        .gesture-highlight { 
            box-shadow: 0 0 20px 5px #fde047;
        }

        .fab-label {
            position: absolute;
            left: 50%;
            transform: translateX(-50%) translateY(5px);
            top: 100%;
            margin-top: 8px;
            padding: 6px 12px;
            background-color: rgba(17, 24, 39, 0.95); color: white; border-radius: 5px;
            font-size: 14px; white-space: nowrap; opacity: 0;
            transition: opacity 0.3s ease, transform 0.3s ease;
            pointer-events: none; visibility: hidden; box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        .sub-fab:hover .fab-label,
        .sub-fab.gesture-highlight .fab-label { 
            opacity: 1; 
            transform: translateX(-50%) translateY(0);
            visibility: visible; 
        }

        #fab-container.open #main-fab #fab-icon-unlocked { transform: rotate(135deg); }
        
        #sub-fab-container.visible .sub-fab { opacity: 1; visibility: visible; }
        
        #sub-fab-container.visible #sub-1 { transform: translateX(-175px) scale(1); } /* Camera */
        #sub-fab-container.visible #sub-9 { transform: translateX(-105px) scale(1); } /* Upload */
        #sub-fab-container.visible #sub-5 { transform: translateX(-35px) scale(1); }  /* Animation */
        #sub-fab-container.visible #sub-4 { transform: translateX(35px) scale(1); }  /* Auto-Rotate */
        #sub-fab-container.visible #sub-8 { transform: translateX(105px) scale(1); }   /* Lock */
        #sub-fab-container.visible #sub-6 { transform: translateX(175px) scale(1); }   /* Reset */
        #sub-fab-container.visible #sub-7 { transform: translateX(245px) scale(1); }  /* Guide */


        #guide-modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 90%;
            max-width: 450px;
            background-color: rgba(10, 20, 40, 0.8);
            backdrop-filter: blur(10px);
            border-radius: 1rem;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(139, 92, 246, 0.5);
            padding: 2rem;
            z-index: 200;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s, width 0.1s linear, font-size 0.1s linear;
            color: #e5e7eb;
            font-size: 15.2px; 
        }
        #guide-modal.visible {
            opacity: 1;
            visibility: visible;
        }
        #guide-modal h2 {
            text-align: center;
            font-size: 1.5em; 
            font-weight: bold;
            color: white;
            margin-bottom: 1.5rem;
            border-bottom: 1px solid rgba(139, 92, 246, 0.3);
            padding-bottom: 0.75rem;
        }
        #guide-modal ul {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        #guide-modal li {
            display: flex;
            align-items: center;
            margin-bottom: 1em;
            font-size: 1em;
        }
        #guide-modal li strong {
            color: #a78bfa;
            width: 130px; 
            flex-shrink: 0;
        }

    </style>
</head>
<body class="bg-gray-900 text-white">
    <div id="three-container"></div>
    <canvas id="hand-overlay"></canvas>

    <div id="loading-overlay" class="fixed inset-0 flex items-center justify-center bg-gray-900 bg-opacity-75 z-40">
        <div class="text-white text-lg p-4 rounded-lg flex items-center space-x-3">
            <div class="animate-spin rounded-full h-8 w-8 border-t-2 border-b-2 border-indigo-500"></div>
            <span id="loading-text">Initializing...</span>
        </div>
    </div>

    <input type="file" id="model-input" accept=".glb,.gltf" style="display: none;">
    
    <div id="sub-fab-container">
        <div id="sub-9" class="sub-fab bg-blue-500 hover:bg-blue-600 text-white fab-button" data-action="upload-model"><span class="fab-label">Upload Model</span><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" y1="3" x2="12" y2="15"/></svg></div>
        <div id="sub-8" class="sub-fab bg-gray-500 hover:bg-gray-600 text-white fab-button" data-action="lock-menu"><span class="fab-label">Lock Menu</span><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect><path d="M7 11V7a5 5 0 0 1 10 0v4"></path></svg></div>
        <div id="sub-7" class="sub-fab bg-indigo-500 hover:bg-indigo-600 text-white fab-button" data-action="show-guide"><span class="fab-label">Show Guide</span><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"/><line x1="12" y1="17" x2="12.01" y2="17"/></svg></div>
        <div id="sub-6" class="sub-fab bg-red-500 hover:bg-red-600 text-white fab-button" data-action="reset-scene"><span class="fab-label">Reset Scene</span><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M20 12a8 8 0 1 0-8-8v8h8z"/><path d="M20 12h-8V4A8 8 0 1 0 20 12z"/></svg></div>
        <div id="sub-5" class="sub-fab bg-pink-500 hover:bg-pink-600 text-white fab-button" data-action="play-animation"><span class="fab-label">Play Animation</span><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M5 3l14 9-14 9V3z"/></svg></div>
        <div id="sub-4" class="sub-fab bg-purple-500 hover:bg-purple-600 text-white fab-button" data-action="toggle-autorotate"><span class="fab-label">Auto-Rotate</span><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M20 12a8 8 0 1 1-8-8"/><path d="M20 12v3h-3"/></svg></div>
        <div id="sub-1" class="sub-fab bg-teal-500 hover:bg-teal-600 text-white fab-button" data-action="toggle-camera"><span class="fab-label">Toggle Camera View</span><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14.5 4h-5L7 7H4a2 2 0 0 0-2 2v9a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2V9a2 2 0 0 0-2-2h-3l-2.5-3z"/><circle cx="12" cy="13" r="3"/></svg></div>
    </div>

    <div id="fab-container">
        <div id="main-fab" class="fab-button bg-indigo-600 hover:bg-indigo-700 text-white">
            <svg id="fab-icon-unlocked" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect><path d="M7 11V7a5 5 0 0 1 9.9-1"></path></svg>
            <svg id="fab-icon-locked" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="hidden"><rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect><path d="M7 11V7a5 5 0 0 1 10 0v4"></path></svg>
        </div>
    </div>

    <div id="guide-modal">
        <h2>Gesture Guide</h2>
        <ul>
            <li><strong>Menu:</strong> Touch Thumb + Pinky</li>
            <li><strong>Click Button:</strong> Touch Thumb to Index Middle Joint</li>
            <li><strong>Lock Menu:</strong> Use the Lock button in the menu</li>
            <li><strong>Unlock Menu:</strong> Make a Punch/Fist gesture</li>
            <li><strong>Auto-Rotate:</strong> Use the Rotate button in the menu</li>
            <li><strong>Play Animation:</strong> Cycle through model animations</li>
            <li><strong>Upload Model:</strong> Load a new .glb or .gltf file</li>
            <li><strong>Drag Model:</strong> Pinch Thumb + Index Tip</li>
            <li><strong>Rotate Model:</strong> Join Index + Middle Finger</li>
            <li><strong>Scale Model:</strong> Pinch with Two Hands</li>
            <li><strong>Drag Guide:</strong> Pinch Thumb + Index Tip</li>
            <li><strong>Scale Guide:</strong> Pinch with Two Hands</li>
            <li><strong>Close Guide:</strong> Touch Thumb to Index Middle Joint</li>
        </ul>
    </div>

    <script type="module">
        import { HandLandmarker, FilesetResolver, DrawingUtils } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/vision_bundle.js";

        let scene, camera, renderer, currentObject, gltfLoader, loadingOverlay, modelInput;
        let videoElement, videoTexture, isVideoBackground = false;
        const originalBackgroundColor = new THREE.Color(0x0a0a0f);
        
        const clock = new THREE.Clock();
        let animationMixer, animationClips = [], currentAction = null;

        let handLandmarker, handOverlayCanvas, handOverlayCtx, drawingUtils;
        let lastVideoTime = -1, handLandmarkerReady = false;
        let specialClickDebounce = false;
        let clickDebounce = false;
        let highlightedFab = null;

        let interactionState = 'idle';
        let rotateLastHandPos = new THREE.Vector2();
        let scaleInitialPinchDist = null, scaleInitialModelScale = null;
        let dragOffset = new THREE.Vector3();
        let fabContainer, subFabContainer, guideModal;
        let isGuideModalVisible = false;
        let guideModalDragOffset = { x: 0, y: 0 };
        let isDraggingGuide = false;
        let guideModalScaleInitialPinchDist = null;
        let guideModalInitialWidth = 0;
        let guideModalInitialFontSize = 0;
        let isMenuLocked = false;
        let punchDebounce = false;
        let isAutoRotating = false;

        function setLoading(isLoading, text = "Loading...") {
            loadingOverlay.querySelector('#loading-text').textContent = text;
            loadingOverlay.classList.toggle('hidden', !isLoading);
        }

        function disposeCurrentObject() {
            if (currentObject) {
                scene.remove(currentObject);
                currentObject.traverse(child => {
                    if (child.isMesh) {
                        child.geometry.dispose();
                        if (child.material.isMaterial) child.material.dispose();
                        else if (Array.isArray(child.material)) child.material.forEach(m => m.dispose());
                    }
                });
            }
            animationMixer = null; animationClips = []; currentAction = null;
        }

        function loadModel(modelInfo) {
            disposeCurrentObject();
            setLoading(true, "Loading 3D Model...");
            gltfLoader.setPath(modelInfo.path || '');
            gltfLoader.load(modelInfo.file, (gltf) => {
                currentObject = gltf.scene;
                currentObject.name = modelInfo.name;

                if (gltf.animations && gltf.animations.length) {
                    animationMixer = new THREE.AnimationMixer(currentObject);
                    animationClips = gltf.animations;
                    currentAction = animationMixer.clipAction(animationClips[0]);
                    currentAction.setLoop(THREE.LoopRepeat).play();
                }

                const box = new THREE.Box3().setFromObject(currentObject);
                const center = box.getCenter(new THREE.Vector3());
                const size = box.getSize(new THREE.Vector3());
                currentObject.position.sub(center);
                const maxDim = Math.max(size.x, size.y, size.z);
                const scale = 3.0 / maxDim;
                currentObject.scale.set(scale, scale, scale);
                scene.add(currentObject);
                setLoading(false);
            }, undefined, (error) => {
                console.error('An error happened during GLTF loading:', error);
                setLoading(false);
            });
        }
        
        function handleHandGestures(landmarks, handedness) {
            if (!landmarks) {
                if(highlightedFab) highlightedFab.classList.remove('gesture-highlight');
                highlightedFab = null;
                return;
            };

            const flippedLandmarks = landmarks.map(hand => 
                hand.map(lm => ({ x: 1 - lm.x, y: lm.y, z: lm.z }))
            );

            const w = window.innerWidth, h = window.innerHeight;
            const THUMB_TIP = 4, INDEX_FINGER_PIP = 6, INDEX_TIP = 8, MIDDLE_TIP = 12, PINKY_TIP = 20;
            
            const indexTipLm = flippedLandmarks[0][INDEX_TIP];
            const middleTipLm = flippedLandmarks[0][MIDDLE_TIP];
            const thumbTipLm = flippedLandmarks[0][THUMB_TIP];
            const pinkyTipLm = flippedLandmarks[0][PINKY_TIP];
            const indexPipLm = flippedLandmarks[0][INDEX_FINGER_PIP];

            const indexTip = { x: indexTipLm.x * w, y: indexTipLm.y * h };
            const middleTip = { x: middleTipLm.x * w, y: middleTipLm.y * h };
            const thumbTip = { x: thumbTipLm.x * w, y: thumbTipLm.y * h };
            const pinkyTip = { x: pinkyTipLm.x * w, y: pinkyTipLm.y * h };

            const clickDist = Math.sqrt(Math.pow(thumbTipLm.x - indexPipLm.x, 2) + Math.pow(thumbTipLm.y - indexPipLm.y, 2) + Math.pow(thumbTipLm.z - indexPipLm.z, 2));
            const newClick = clickDist < 0.04;

            const dist = (p1, p2) => Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
            const normalClick = dist(indexTip, middleTip) < 40;
            const specialClick = dist(thumbTip, pinkyTip) < 50;

            const getIsPunch = (hand) => {
                if (!hand || hand.length === 0) return false;
                const palmCenterY = (hand[0].y + hand[5].y + hand[17].y) / 3;
                const palmCenterX = (hand[0].x + hand[5].x + hand[17].x) / 3;
                const palmCenter = { x: palmCenterX, y: palmCenterY };
                const fingerTips = [hand[8], hand[12], hand[16], hand[20]];
                const dist2D = (p1, p2) => Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
                let curledFingers = 0;
                const threshold = 0.07;
                for (const tip of fingerTips) {
                    if (dist2D(tip, palmCenter) < threshold) {
                        curledFingers++;
                    }
                }
                return curledFingers >= 3;
            };
            const isPunch = getIsPunch(flippedLandmarks[0]);

            if (isPunch && !punchDebounce) {
                if (isMenuLocked) {
                    isMenuLocked = false;
                    document.getElementById('fab-icon-locked').classList.add('hidden');
                    document.getElementById('fab-icon-unlocked').classList.remove('hidden');
                }
                punchDebounce = true;
                setTimeout(() => { punchDebounce = false; }, 1000);
            }

            if (isGuideModalVisible) {
                handleGuideModalGestures(flippedLandmarks, newClick);
                return; 
            }
            
            if (!isMenuLocked) {
                if (specialClick && !specialClickDebounce) {
                    fabContainer.classList.toggle('open');
                    subFabContainer.classList.toggle('visible');
                    specialClickDebounce = true;
                    setTimeout(() => { specialClickDebounce = false; }, 500);
                }

                if (subFabContainer.classList.contains('visible')) {
                    const subFabs = Array.from(document.querySelectorAll('.sub-fab'))
                                         .sort((a, b) => a.getBoundingClientRect().left - b.getBoundingClientRect().left);
                    const numItems = subFabs.length;
                    if (numItems > 0) {
                        const topMargin = h * 0.40;
                        const bottomMargin = h * 0.40;
                        if (indexTip.y >= topMargin && indexTip.y <= h - bottomMargin) {
                            const sideMargin = w * 0.15;
                            const interactiveWidth = w - (sideMargin * 2);
                            if (indexTip.x < sideMargin || indexTip.x > w - sideMargin) {
                                if (highlightedFab) {
                                    highlightedFab.classList.remove('gesture-highlight');
                                    highlightedFab = null;
                                }
                            } else {
                                const relativeX = indexTip.x - sideMargin;
                                const segmentWidth = interactiveWidth / numItems;
                                let selectedIndex = Math.floor(relativeX / segmentWidth);
                                selectedIndex = Math.max(0, Math.min(numItems - 1, selectedIndex));
                                const selectedFab = subFabs[selectedIndex];
                                if (highlightedFab !== selectedFab) {
                                    if (highlightedFab) highlightedFab.classList.remove('gesture-highlight');
                                    highlightedFab = selectedFab;
                                    highlightedFab.classList.add('gesture-highlight');
                                }
                            }
                        } else {
                            if (highlightedFab) {
                                highlightedFab.classList.remove('gesture-highlight');
                                highlightedFab = null;
                            }
                        }
                    } else if (highlightedFab) {
                        highlightedFab.classList.remove('gesture-highlight');
                        highlightedFab = null;
                    }
                    if (newClick && !clickDebounce && highlightedFab) {
                        highlightedFab.click();
                        clickDebounce = true;
                        setTimeout(() => { clickDebounce = false; }, 500);
                    }
                    handleModelInteraction(null, null);
                    return;
                }
            }
            
            if (highlightedFab) {
                highlightedFab.classList.remove('gesture-highlight');
                highlightedFab = null;
            }
            handleModelInteraction(flippedLandmarks, handedness, normalClick);
        }

        function handleGuideModalGestures(landmarks, newClick) {
             const w = window.innerWidth, h = window.innerHeight;
            const THUMB_TIP = 4, INDEX_TIP = 8;

            const getPinch = (hand) => {
                if (!hand || hand.length === 0) return { isPinching: false };
                const thumbTip = hand[THUMB_TIP];
                const indexTip = hand[INDEX_TIP];
                const pinchDist = Math.sqrt(Math.pow(thumbTip.x - indexTip.x, 2) + Math.pow(thumbTip.y - indexTip.y, 2) + Math.pow(thumbTip.z - indexTip.z, 2));
                return { isPinching: pinchDist < 0.06, center: { x: (thumbTip.x + indexTip.x) / 2 * w, y: (thumbTip.y + indexTip.y) / 2 * h } };
            };

            const hand1 = landmarks[0] || [];
            const hand2 = landmarks[1] || [];
            const pinch1 = getPinch(hand1);
            const pinch2 = getPinch(hand2);

            if (hand2.length > 0 && pinch1.isPinching && pinch2.isPinching) {
                isDraggingGuide = false;
                const dist = Math.sqrt(Math.pow(pinch1.center.x - pinch2.center.x, 2) + Math.pow(pinch1.center.y - pinch2.center.y, 2));
                if (guideModalScaleInitialPinchDist === null) {
                    guideModalScaleInitialPinchDist = dist;
                    guideModalInitialWidth = guideModal.offsetWidth;
                    guideModalInitialFontSize = parseFloat(window.getComputedStyle(guideModal).fontSize);
                } else {
                    const scaleFactor = dist / guideModalScaleInitialPinchDist;
                    guideModal.style.width = `${guideModalInitialWidth * scaleFactor}px`;
                    guideModal.style.fontSize = `${guideModalInitialFontSize * scaleFactor}px`;
                }
                return;
            }
            guideModalScaleInitialPinchDist = null;

            if (newClick && !clickDebounce) {
                handleFabAction('show-guide');
                clickDebounce = true;
                setTimeout(() => { clickDebounce = false; }, 500);
                return;
            }
            
            if (pinch1.isPinching) {
                if (!isDraggingGuide) {
                    isDraggingGuide = true;
                    const rect = guideModal.getBoundingClientRect();
                    guideModalDragOffset.x = pinch1.center.x - rect.left;
                    guideModalDragOffset.y = pinch1.center.y - rect.top;
                }
                guideModal.style.left = `${pinch1.center.x - guideModalDragOffset.x}px`;
                guideModal.style.top = `${pinch1.center.y - guideModalDragOffset.y}px`;
                guideModal.style.transform = `none`;
            } else {
                isDraggingGuide = false;
            }
        }

        function handleModelInteraction(landmarks, handedness, normalClick) {
            if (!currentObject || !landmarks) {
                if (interactionState !== 'idle' && isAutoRotating) {
                    // No hands detected, resume auto-rotation if it was on
                }
                interactionState = 'idle';
                return;
            }

            let wasInteracting = interactionState !== 'idle';

            const w = window.innerWidth, h = window.innerHeight;
            const THUMB_TIP = 4, INDEX_TIP = 8;
            const getPinch = (hand) => {
                const thumbTip = hand[THUMB_TIP];
                const indexTip = hand[INDEX_TIP];
                const pinchDist = Math.sqrt(Math.pow(thumbTip.x - indexTip.x, 2) + Math.pow(thumbTip.y - indexTip.y, 2) + Math.pow(thumbTip.z - indexTip.z, 2));
                return { isPinching: pinchDist < 0.06, center: {x: (thumbTip.x + indexTip.x) / 2 * w, y: (thumbTip.y + indexTip.y) / 2 * h}};
            };

            const hand1 = landmarks[0] || [];
            const hand2 = landmarks[1] || [];
            const pinch1 = getPinch(hand1);

            if (hand2.length > 0) {
                const pinch2 = getPinch(hand2);
                if (pinch1.isPinching && pinch2.isPinching) {
                    interactionState = 'scaling';
                    const dist = Math.sqrt(Math.pow(pinch1.center.x - pinch2.center.x, 2) + Math.pow(pinch1.center.y - pinch2.center.y, 2));
                    if(scaleInitialPinchDist === null) {
                        scaleInitialPinchDist = dist;
                        scaleInitialModelScale = currentObject.scale.clone();
                    } else {
                        const scaleFactor = dist / scaleInitialPinchDist;
                        currentObject.scale.copy(scaleInitialModelScale).multiplyScalar(scaleFactor);
                    }
                    return; 
                }
            }
            scaleInitialPinchDist = null;
            scaleInitialModelScale = null;

            if (normalClick) {
                if (interactionState !== 'rotating') {
                    interactionState = 'rotating';
                    rotateLastHandPos.set(pinch1.center.x, pinch1.center.y);
                }
                const dx = pinch1.center.x - rotateLastHandPos.x;
                const dy = pinch1.center.y - rotateLastHandPos.y;
                currentObject.rotation.y += dx * 0.01;
                currentObject.rotation.x += dy * 0.01;
                rotateLastHandPos.set(pinch1.center.x, pinch1.center.y);
                return;
            }

            if (pinch1.isPinching) {
                if (interactionState !== 'dragging') {
                    interactionState = 'dragging';
                    const vec = new THREE.Vector3((pinch1.center.x / w) * 2 - 1, -(pinch1.center.y / h) * 2 + 1, 0.5).unproject(camera);
                    const dir = vec.sub(camera.position).normalize();
                    const distance = -camera.position.z / dir.z;
                    const pos = camera.position.clone().add(dir.multiplyScalar(distance));
                    dragOffset.copy(currentObject.position).sub(pos);
                }
                const vec = new THREE.Vector3((pinch1.center.x / w) * 2 - 1, -(pinch1.center.y / h) * 2 + 1, 0.5).unproject(camera);
                const dir = vec.sub(camera.position).normalize();
                const distance = -camera.position.z / dir.z;
                const pos = camera.position.clone().add(dir.multiplyScalar(distance));
                currentObject.position.copy(pos.add(dragOffset));
                return;
            }

            interactionState = 'idle';
        }

        function initThreeScene() {
            scene = new THREE.Scene();
            scene.background = originalBackgroundColor;
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 5;
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('three-container').appendChild(renderer.domElement);
            gltfLoader = new THREE.GLTFLoader();
            
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.2);
            directionalLight.position.set(5, 10, 7.5);
            scene.add(directionalLight);
            
            const fillLight = new THREE.DirectionalLight(0xffffff, 0.4);
            fillLight.position.set(-5, 0, -5);
            scene.add(fillLight);

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
                if (handOverlayCanvas) {
                    handOverlayCanvas.width = window.innerWidth;
                    handOverlayCanvas.height = window.innerHeight;
                }
            }, false);
        }
        
        async function createHandLandmarker() {
            setLoading(true, "Loading Hand Model...");
            const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/wasm");
            handLandmarker = await HandLandmarker.createFromOptions(vision, {
                baseOptions: { modelAssetPath: `https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/1/hand_landmarker.task`, delegate: "GPU" },
                runningMode: "VIDEO", numHands: 2
            });
            drawingUtils = new DrawingUtils(handOverlayCtx);
            handLandmarkerReady = true;
            setLoading(false);
        }

        function animate() {
            requestAnimationFrame(animate);
            if (animationMixer) animationMixer.update(clock.getDelta());
            
            if (isAutoRotating && currentObject && interactionState === 'idle') {
                currentObject.rotation.y += 0.005;
            }

            if (handLandmarkerReady && videoElement?.readyState >= 3 && lastVideoTime !== videoElement.currentTime) {
                lastVideoTime = videoElement.currentTime;
                const result = handLandmarker.detectForVideo(videoElement, performance.now());
                handOverlayCtx.clearRect(0, 0, handOverlayCanvas.width, handOverlayCanvas.height);
                if (result.landmarks && result.landmarks.length > 0) {
                    handOverlayCtx.save();
                    handOverlayCtx.scale(-1, 1);
                    handOverlayCtx.translate(-handOverlayCanvas.width, 0);
                    for(let i=0; i < result.landmarks.length; i++){
                        const landmarks = result.landmarks[i];
                        drawingUtils.drawConnectors(landmarks, HandLandmarker.HAND_CONNECTIONS, { color: "rgba(255, 255, 255, 0.6)", lineWidth: 3 });
                        drawingUtils.drawLandmarks(landmarks, { color: "#4F46E5", radius: 5 });
                    }
                    handOverlayCtx.restore();
                    handleHandGestures(result.landmarks, result.handedness);
                } else {
                    handleHandGestures(null, null);
                }
            }
            renderer.render(scene, camera);
        }
        
        async function initCamera() {
            if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
                const stream = await navigator.mediaDevices.getUserMedia({ video: true });
                videoElement = document.createElement('video');
                videoElement.srcObject = stream;
                videoElement.playsInline = true; videoElement.muted = true;
                return new Promise((resolve) => {
                    videoElement.addEventListener('loadeddata', () => {
                        videoElement.play();
                        videoTexture = new THREE.VideoTexture(videoElement);
                        videoTexture.wrapS = THREE.RepeatWrapping;
                        videoTexture.repeat.x = -1;
                        resolve();
                    });
                });
            }
        }

        function toggleCameraBackground() {
            if (!videoTexture) return;
            isVideoBackground = !isVideoBackground;
            scene.background = isVideoBackground ? videoTexture : originalBackgroundColor;
        }

        function handleFabAction(action) {
            switch(action) {
                case 'reset-scene': loadModel({ name: 'Damaged Helmet', path: 'https://threejs.org/examples/models/gltf/DamagedHelmet/glTF/', file: 'DamagedHelmet.gltf' }); break;
                case 'play-animation':
                    if (animationClips && animationClips.length > 0) {
                        const nextClipIndex = (animationClips.indexOf(currentAction.getClip()) + 1) % animationClips.length;
                        const nextAction = animationMixer.clipAction(animationClips[nextClipIndex]);
                        currentAction.fadeOut(0.5);
                        nextAction.reset().fadeIn(0.5).play();
                        currentAction = nextAction;
                    }
                    break;
                case 'toggle-camera': toggleCameraBackground(); break;
                case 'show-guide':
                    isGuideModalVisible = !isGuideModalVisible;
                    guideModal.classList.toggle('visible', isGuideModalVisible);
                    break;
                case 'lock-menu':
                    isMenuLocked = true;
                    document.getElementById('fab-icon-unlocked').classList.add('hidden');
                    document.getElementById('fab-icon-locked').classList.remove('hidden');
                    break;
                case 'toggle-autorotate':
                    isAutoRotating = !isAutoRotating;
                    break;
                case 'upload-model':
                    modelInput.click();
                    break;
            }
        }
        
        window.onload = async () => {
            loadingOverlay = document.getElementById('loading-overlay');
            handOverlayCanvas = document.getElementById('hand-overlay');
            handOverlayCtx = handOverlayCanvas.getContext('2d');
            fabContainer = document.getElementById('fab-container');
            subFabContainer = document.getElementById('sub-fab-container');
            guideModal = document.getElementById('guide-modal');
            modelInput = document.getElementById('model-input');
            handOverlayCanvas.width = window.innerWidth;
            handOverlayCanvas.height = window.innerHeight;

            initThreeScene();
            
            document.querySelectorAll('.sub-fab').forEach(fab => {
                fab.addEventListener('click', () => {
                    handleFabAction(fab.dataset.action);
                    fabContainer.classList.remove('open');
                    subFabContainer.classList.remove('visible');
                });
            });
             document.getElementById('main-fab').addEventListener('click', () => {
                if (!isMenuLocked) {
                    fabContainer.classList.toggle('open');
                    subFabContainer.classList.toggle('visible');
                }
             });

            modelInput.addEventListener('change', (event) => {
                const file = event.target.files[0];
                if (file) {
                    const url = URL.createObjectURL(file);
                    loadModel({ name: file.name, file: url });
                }
            });
            
            await initCamera(); 
            await createHandLandmarker();
            loadModel({ name: 'Damaged Helmet', path: 'https://threejs.org/examples/models/gltf/DamagedHelmet/glTF/', file: 'DamagedHelmet.gltf' });
            
            animate();
        }
    </script>
</body>
</html>